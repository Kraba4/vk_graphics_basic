#version 430
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "common.h"
    // Sort 16 sortable elements
#define NUM_ELEMENTS 1024

layout( local_size_x = 512 ) in;

layout (std430, binding = 0 ) buffer SortData 
{
    Particle value [];
};

layout(std430, binding = 1) buffer b 
{
    vec4 aliveBound_spawnerBound;
};

    // Use local memory to minimize memory access cost.
shared Particle local [NUM_ELEMENTS];

void    localCompareAndSwap ( uvec2 idx )
{
    if ( local[idx.x].velocity.w < local[idx.y].velocity.w ) 
    {
        Particle tmp = local[idx.x];

        local[idx.x] = local[idx.y];
        local[idx.y] = tmp;
    }
}

void    flip ( uint h )
{
    uint    t       = gl_LocalInvocationID.x;
    uint    q       = ((2 * t) / h) * h;
    uint    t2      = t % (h / 2);
    uvec2   indices = q + uvec2 ( t2, h - t2 - 1 );

    localCompareAndSwap ( indices );
}

void    disperse ( uint h )
{
    uint    t       = gl_LocalInvocationID.x;
    uint    q       = ((2 * t) / h) * h;
    uint    t2      = t % (h / 2);
    uvec2   indices = q + uvec2 ( t2, t2 + (h / 2) );

    localCompareAndSwap ( indices );
}

void    main ()
{
    int    t = int(gl_LocalInvocationID.x);
    int     n = NUM_ELEMENTS;

        // each thread loads two elements to shared memory
    local [t*2    ] = value [t*2    ];
    local [t*2 + 1] = value [t*2 + 1];
 
    for ( uint h = 2; h <= n; h *= 2 )
    {
        barrier ();
        flip    ( h );

        for ( uint hh = h / 2; hh > 1; hh /= 2 ) 
        {
            barrier  ();
            disperse ( hh );
        }
    }

    barrier ();
    
    if (local[t*2].velocity.w > -9999 && local[t*2 + 1].velocity.w < -9998) {
        aliveBound_spawnerBound.x = t*2;
    } else if (abs(local[t*2].velocity.w - (-10000)) < 10 && abs(local[t*2 + 1].velocity.w - (-20000)) < 10) {
        aliveBound_spawnerBound.y = t*2;
    }
    if (t*2 - 1 >= 0) {
        if (local[t*2 - 1].velocity.w > -9999 && local[t*2].velocity.w < -9998) {
            aliveBound_spawnerBound.x = t*2 - 1;
        } else if (abs(local[t*2 - 1].velocity.w - (-10000)) < 10 && abs(local[t*2].velocity.w - (-20000)) < 10) {
            aliveBound_spawnerBound.y = t*2 - 1;
        }
    } else {
        if (local[0].velocity.w < -9998) {
             aliveBound_spawnerBound.x = -1;
        }
    }
        // write data back
    value [t*2    ] = local [t*2    ];
    value [t*2 + 1] = local [t*2 + 1];
}
