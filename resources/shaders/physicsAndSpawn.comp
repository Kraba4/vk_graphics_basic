#version 430
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "common.h"

layout( local_size_x = 64 ) in;

layout(std430, binding = 0) buffer a 
{
    Particle particles[];
};

layout(std430, binding = 1) buffer b 
{
    vec4 aliveBound_spawnerBound;
};

layout(binding = 2) uniform AppData
{
  SpawnParams Params;
};


layout( push_constant ) uniform params {
   mat4 mProjView;
   float dt;
} PushConstant;

Particle spawn(int type, vec3 position) {
    Particle newParticle;
    if (type == 1) {
        newParticle.positionAndTimeToLive = vec4(position, 4);
        vec4 proj = PushConstant.mProjView * vec4(position, 1.0f);
        newParticle.velocity = vec4(1,0,0, proj.z);
        newParticle.spawner = vec4(0);
    } 
    return newParticle;
}

void main() 
{
    const int nAlive    = int(aliveBound_spawnerBound.y);
    const int nSpawners = int(aliveBound_spawnerBound.y - aliveBound_spawnerBound.x);
    const float dt      = PushConstant.dt;
    if (gl_GlobalInvocationID.x > nAlive) {
        return;
    }

    Particle local_particle = particles[gl_GlobalInvocationID.x];
    float timeToLive = local_particle.positionAndTimeToLive.w;
    if (timeToLive - dt > 0) {
        int spawnType = int(local_particle.spawner.x);
        vec3 position = local_particle.positionAndTimeToLive.xyz;
        if (spawnType > 0) {
            // local_particle.velocity = vec4(velocity, -100000);
            local_particle.spawner.y += dt;
            local_particle.spawner.z = Params.time.x;
            if (local_particle.spawner.y > local_particle.spawner.z && (local_particle.spawner.w > 0 || local_particle.spawner.w <= -2)) {
                local_particle.spawner.y = 0;
                local_particle.spawner.w -= 1;
                particles[gl_GlobalInvocationID.x + nSpawners] = spawn(spawnType, position);
            }
        } else {
            vec3 velocity = local_particle.velocity.xyz;
            float speed = 0.4;
            velocity += 8.0 * vec3(0, 1, 0) * dt;
            position += speed * normalize(velocity) * dt;
            timeToLive -= dt;
            local_particle.positionAndTimeToLive = vec4(position, timeToLive);
            vec4 proj = PushConstant.mProjView * vec4(position, 1.0f);
            local_particle.velocity = vec4(velocity, proj.z);
        }
    } else {
        local_particle.positionAndTimeToLive = vec4(-1);
        local_particle.velocity = vec4(0,0,0, -20000);
    }
    particles[gl_GlobalInvocationID.x] = local_particle;
}